---
globs: backend/lykke/domain/value_objects/**/*.py
alwaysApply: false
---

# Domain Value Objects Rules

Value objects are small domain types with no identity. Treat them as immutable
even though they are not frozen dataclasses in this codebase.

---

## Base Classes

Value objects extend `BaseValueObject`, with request/response wrappers for API
shapes:

```python
from dataclasses import dataclass
from datetime import time

from lykke.domain.value_objects.base import (
    BaseRequestObject,
    BaseResponseObject,
    BaseValueObject,
)
from lykke.domain.value_objects.routine_definition import TimeWindow


@dataclass(kw_only=True)
class TimeWindow(BaseValueObject):
    """Time window information for a task."""

    available_time: time | None = None
    start_time: time | None = None
    end_time: time | None = None
    cutoff_time: time | None = None


@dataclass(kw_only=True)
class PagedQueryRequest(BaseRequestObject):
    limit: int = 50
    offset: int = 0
```

---

## Key Rules

1. **Use `@dataclass(kw_only=True)`** - keyword-only fields everywhere
2. **Treat as immutable** - create new instances instead of mutating
3. **Prefer Enums for fixed sets** - statuses, categories, types
4. **Query objects extend `BaseQuery`** - filtering/search objects
5. **Update objects extend `BaseUpdateObject`** - partial updates
6. **No identity** - compare by value, not by ID

---

## Common Patterns

### Enum-based Value Objects

```python
from enum import Enum


class TaskStatus(str, Enum):
    COMPLETE = "COMPLETE"
    NOT_READY = "NOT_READY"
    READY = "READY"
    PUNT = "PUNT"
    NOT_STARTED = "NOT_STARTED"
    PENDING = "PENDING"
```

### Query Objects

```python
from dataclasses import dataclass
from datetime import date as dt_date
from uuid import UUID

from lykke.domain.value_objects.query import DateQuery


@dataclass(kw_only=True)
class TaskQuery(DateQuery):
    """Query object for searching tasks."""

    date: dt_date | None = None
    ids: list[UUID] | None = None
    routine_definition_ids: list[UUID] | None = None
    is_adhoc: bool | None = None
```

### Update Objects

```python
from dataclasses import dataclass

from lykke.domain.value_objects.update import BaseUpdateObject


@dataclass(kw_only=True)
class TaskUpdateObject(BaseUpdateObject):
    """Update object for partial task updates."""

    name: str | None = None
    status: TaskStatus | None = None
    time_window: TimeWindow | None = None
    tags: list[str] | None = None
```

### LLM Run Snapshots

```python
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any
from uuid import UUID

from lykke.domain.value_objects.ai_chat import LLMProvider
from lykke.domain.value_objects.base import BaseValueObject


@dataclass(kw_only=True)
class LLMReferencedEntitySnapshot(BaseValueObject):
    entity_type: str
    entity_id: UUID


@dataclass(kw_only=True)
class LLMToolCallResultSnapshot(BaseValueObject):
    tool_name: str
    arguments: dict[str, Any] = field(default_factory=dict)
    result: Any


@dataclass(kw_only=True)
class LLMRunResultSnapshot(BaseValueObject):
    tool_calls: list[LLMToolCallResultSnapshot] = field(default_factory=list)
    prompt_context: dict[str, Any]
    current_time: datetime
    llm_provider: LLMProvider
    system_prompt: str
    context_prompt: str
    ask_prompt: str
    tools_prompt: str
    referenced_entities: list[LLMReferencedEntitySnapshot] = field(default_factory=list)
```

### Paged Request/Response

```python
from dataclasses import dataclass
from typing import Generic, TypeVar

from lykke.domain.value_objects.base import BaseRequestObject, BaseResponseObject
from lykke.domain.value_objects.query import BaseQuery

T = TypeVar("T", bound=BaseQuery)
EntityType = TypeVar("EntityType")


@dataclass(kw_only=True)
class PagedQueryRequest(BaseRequestObject, Generic[T]):
    limit: int = 50
    offset: int = 0
    query: T | None = None


@dataclass(kw_only=True)
class PagedQueryResponse(BaseResponseObject, Generic[EntityType]):
    items: list[EntityType]
    total: int
    limit: int
    offset: int
    has_next: bool
    has_previous: bool
```

---

## Gotchas

### 1. Value Objects Are Not Frozen

**Issue:** Dataclasses are not frozen, so mutation is possible but discouraged.

```python
# Wrong: mutating an instance
schedule.start_time = time(10, 0)

# Right: create a new instance
updated = schedule.clone(start_time=time(10, 0))
```

### 2. Query Object Defaults

**Issue:** Defaults should mirror the actual `BaseQuery` fields.

```python
@dataclass(kw_only=True)
class BaseQuery:
    limit: int | None = None
    offset: int | None = None
    order_by: str | None = None
    order_by_desc: bool | None = None
    created_before: datetime | None = None
    created_after: datetime | None = None
```

### 3. Update Objects with None

**Issue:** Update objects use `None` to indicate "don't update this field".

```python
# Only update name, leave other fields unchanged
update = TaskUpdateObject(name="New Name")  # status=None means don't change
```

---

## Testing Guidance

### Testing Value Objects

Test value object behavior:

```python
def test_task_status_enum():
    """Test TaskStatus enum values."""
    assert TaskStatus.COMPLETE.value == "COMPLETE"
    assert TaskStatus.NOT_STARTED.value == "NOT_STARTED"

def test_task_query_defaults():
    """Test TaskQuery has sensible defaults."""
    query = TaskQuery()
    assert query.limit is None
    assert query.offset is None
    assert query.date is None

def test_task_schedule_clone():
    """Test TimeWindow cloning."""
    time_window = TimeWindow(start_time=time(9, 0))
    updated = schedule.clone(start_time=time(9, 0))
    assert updated.start_time == time(9, 0)
    assert schedule.start_time is None
```

### Test Location

Value object tests go in:
- `tests/unit/domain/test_*.py` - Value object tests
- No mocking needed (pure data structures)
