---
globs: backend/planned/domain/entities/**/*.py
alwaysApply: false
---

# Domain Entities Rules

Entities represent business objects with identity and lifecycle. All entities are aggregate roots in this codebase.

---

## Base Classes

All entities extend `BaseEntityObject` from `domain/entities/base.py`:

```python
from planned.domain.entities.base import BaseEntityObject
from planned.domain.value_objects.update import BaseUpdateObject
from planned.domain.events.base import EntityUpdatedEvent

@dataclass(kw_only=True)
class TaskEntity(BaseEntityObject[TaskUpdateObject, TaskUpdatedEvent]):
    id: UUID = field(default_factory=uuid4)
    user_id: UUID
    name: str
    status: TaskStatus
    # ... other fields
```

---

## Key Rules

1. **All entities are aggregate roots** - They own business invariants and emit domain events
2. **Use `@dataclass(kw_only=True)`** - All fields must be keyword-only
3. **IDs use `default_factory=uuid4`** - Auto-generate UUIDs if not provided
4. **Business logic in methods** - State changes happen through entity methods
5. **Raise `DomainError`** for invalid operations (from `planned.core.exceptions`)
6. **Use `_add_event()`** to emit domain events
7. **Call `create()`, `update()`, `delete()`** to mark entity lifecycle changes

---

## Entity Methods

Entities expose business methods that enforce invariants:

```python
def record_action(self, action: ActionEntity) -> TaskStatus:
    """Record an action on this task.

    Enforces business rules:
    - Cannot complete an already-completed task
    - Records completion timestamp
    - Updates status based on action type

    Returns:
        The old status before the change
    """
    if action.type == ActionType.COMPLETE:
        if self.status == TaskStatus.COMPLETE:
            raise DomainError("Task is already complete")
        self.status = TaskStatus.COMPLETE
        self.completed_at = datetime.now(UTC)
        # Note: Domain events are raised by aggregate root
    return old_status
```

---

## Domain Events

Entities emit domain events through methods on `BaseEntityObject`:

- `create()` - Marks entity as newly created, adds `EntityCreatedEvent`
- `update(update_object)` - Marks entity as updated, adds `EntityUpdatedEvent`
- `delete()` - Marks entity as deleted, adds `EntityDeletedEvent`
- `_add_event(event)` - Add custom domain event

**Important:** Events are collected by the Unit of Work and dispatched after transaction commit. Entities do not dispatch events directly.

---

## Examples

**Creating an Entity:**

```python
task = TaskEntity(
    user_id=user_id,
    scheduled_date=date(2025, 1, 1),
    name="Complete project",
    status=TaskStatus.NOT_STARTED,
    task_definition=task_def,
    category=TaskCategory.WORK,
    frequency=TaskFrequency.ONCE,
)
task.create()  # Mark as newly created, adds EntityCreatedEvent
```

**Updating an Entity:**

```python
update_obj = TaskUpdateObject(name="Updated name")
task.update(update_obj)  # Adds EntityUpdatedEvent
```

**Business Logic Method:**

```python
def mark_pending(self) -> TaskStatus:
    """Mark task as pending when scheduled time arrives."""
    old_status = self.status
    if self.status == TaskStatus.NOT_STARTED:
        self.status = TaskStatus.PENDING
    return old_status
```

---

## Gotchas

### 1. Entity ID Generation

**Issue:** Entities use `default_factory=uuid4`, but you can also provide an ID explicitly.

```python
# Auto-generate ID
task = TaskEntity(user_id=..., name=..., ...)

# Explicit ID (useful for testing or when ID comes from external source)
task = TaskEntity(id=existing_id, user_id=..., name=..., ...)
```

### 2. Domain Events Are Collected, Not Dispatched

**Issue:** Calling `_add_event()` or `create()`/`update()`/`delete()` doesn't immediately dispatch events. Events are collected and dispatched after transaction commit by the Unit of Work.

```python
task.create()  # Adds EntityCreatedEvent to _domain_events list
# Event is NOT dispatched here
# Event will be dispatched after uow.commit()
```

### 3. Entity Methods Should Return Old State

**Issue:** When entity methods change state, they often need to return the old state for event raising by the aggregate root.

```python
def mark_complete(self) -> TaskStatus:
    old_status = self.status
    self.status = TaskStatus.COMPLETE
    return old_status  # Return old state for event
```

---

## Testing Guidance

### Unit Testing Entities

Test entity business methods in isolation:

```python
@pytest.mark.asyncio
def test_record_action_completes_task(test_task: TaskEntity):
    """Test that recording COMPLETE action marks task as complete."""
    action = ActionEntity(type=ActionType.COMPLETE)

    old_status = test_task.record_action(action)

    assert test_task.status == TaskStatus.COMPLETE
    assert test_task.completed_at is not None
    assert old_status == TaskStatus.NOT_STARTED
```

### Testing Domain Events

Test that entities emit correct events:

```python
def test_create_adds_created_event(test_task: TaskEntity):
    """Test that create() adds EntityCreatedEvent."""
    test_task.create()

    events = test_task.collect_events()
    assert len(events) == 1
    assert isinstance(events[0], EntityCreatedEvent)
```

### Test Location

Entity tests go in:

- `tests/unit/domain/test_*.py` - Entity tests
- Use fixtures from `tests/conftest.py` or `tests/unit/conftest.py`
- No mocking needed (pure business logic)

### Test Patterns

1. **Test business rules** - Verify invariants are enforced
2. **Test state transitions** - Verify methods change state correctly
3. **Test domain events** - Verify correct events are emitted
4. **Test error cases** - Verify `DomainError` is raised for invalid operations
5. **Use parametrize** - Test multiple scenarios with `@pytest.mark.parametrize`

---

## Common Patterns

### Factory Methods

Entities often have factory methods for common creation patterns:

```python
@classmethod
def create_for_date(
    cls,
    date: dt_date,
    user_id: UUID,
    template: DayTemplateEntity,
) -> "DayEntity":
    """Create a Day entity for a specific date."""
    day_id = cls.id_from_date_and_user(date, user_id)
    return cls(
        id=day_id,
        user_id=user_id,
        date=date,
        template=template,
        ...
    )
```

### ID Generation Helpers

Static methods for generating IDs:

```python
@staticmethod
def id_from_date_and_user(date: dt_date, user_id: UUID) -> UUID:
    """Generate a deterministic ID from date and user."""
    return uuid5(user_id, str(date))
```

### Status Transitions

Methods that handle state transitions:

```python
def transition_to(self, new_status: TaskStatus) -> TaskStatus:
    """Transition to a new status with validation."""
    if not self.can_transition_to(new_status):
        raise DomainError(f"Cannot transition from {self.status} to {new_status}")
    old_status = self.status
    self.status = new_status
    return old_status
```
