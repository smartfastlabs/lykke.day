---
globs: backend/**/*.py
alwaysApply: false
---

# Backend Architecture & Contribution Guide

This codebase follows a **strict Clean Architecture (Hexagonal Architecture)** with **CQRS (Command Query Responsibility Segregation)**. Understanding and respecting layer boundaries is critical. Changes that violate these rules will not be accepted.

---

## Quick Reference: Make Commands

All commands should be run from the `backend/` directory:

```bash
# Database Migrations
make migrate-dev                    # Apply migrations to dev database
make migrate-test                   # Apply migrations to test database
make migrate-create MSG='message'   # Create a new migration

# Testing & Quality
make test               # Run all tests
make test-target TARGET=test_name   # Run specific test by name
make test-target TARGET=path/to/test.py  # Run specific test file
make typecheck          # Run mypy type checking
make check-mappers      # Check for missing mappers/schemas
make check              # Run both typecheck and tests

# Type Generation
make export-openapi     # Export OpenAPI schema
make generate-types     # Generate TypeScript types from OpenAPI
```

**IMPORTANT: Always use `poetry run` for any Python commands:**

```bash
poetry run alembic upgrade head    # Run migrations
poetry run pytest tests/unit       # Run unit tests
poetry run mypy lykke              # Type check
```

---

## Architecture Overview

The codebase is organized into five layers, with strict dependency rules:

```
┌─────────────────────────────────────────────────────────────────┐
│                     PRESENTATION LAYER                          │
│  FastAPI routers, API schemas, request/response handling        │
│  presentation/api/routers/, presentation/api/schemas/            │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼ depends on
┌─────────────────────────────────────────────────────────────────┐
│                     APPLICATION LAYER                           │
│  Commands, Queries, Repository & Gateway protocols, Events      │
│  application/commands/, application/queries/,                    │
│  application/repositories/, application/gateways/                │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼ depends on
┌─────────────────────────────────────────────────────────────────┐
│                      DOMAIN LAYER                               │
│  Entities, Value Objects, Domain Events, Domain Services        │
│  domain/entities/, domain/value_objects/, domain/events/         │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                   INFRASTRUCTURE LAYER                          │
│  Repository implementations, Gateway implementations, Database  │
│  infrastructure/repositories/, infrastructure/gateways/          │
│  infrastructure/database/, infrastructure/unit_of_work.py       │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                       CORE LAYER                                │
│  Configuration, constants, exceptions, shared utilities         │
│  core/config.py, core/constants.py, core/exceptions.py,         │
│  core/utils/                                                     │
└─────────────────────────────────────────────────────────────────┘
```

---

## Layer Overview

### Domain Layer (`lykke/domain/`)

**Purpose:** Pure business logic with zero external dependencies. Contains entities, value objects, domain events, and domain services.

**Location:** `backend/lykke/domain/`

**Key Components:**

- `entities/` - Business objects (Task, Day, User, etc.) with business methods
- `value_objects/` - Immutable value types (TaskStatus, Query objects, etc.)
- `events/` - Domain events emitted by aggregates
- `services/` - Pure domain services (no I/O)

**What It Does:**

- Enforces business rules and invariants
- Defines the core business model
- Emits domain events for side effects
- Contains no infrastructure or framework code

**For Details:** See `.cursor/rules/domain.mdc`

---

### Application Layer (`lykke/application/`)

**Purpose:** Business logic orchestration using CQRS pattern. Defines protocols (interfaces) and implements commands/queries.

**Location:** `backend/lykke/application/`

**Key Components:**

- `commands/` - Write operations (mutations) that use Unit of Work
- `queries/` - Read operations that use read-only repositories
- `repositories/` - Repository protocol definitions (interfaces)
- `gateways/` - External service protocol definitions (interfaces)
- `unit_of_work.py` - Unit of Work protocol
- `events/` - Domain event handlers and signal registration
- `llm_usecases/` - LLM-based use case implementations

**What It Does:**

- Orchestrates business operations through commands and queries
- Defines contracts (protocols) for data access and external services
- Handles transaction boundaries via Unit of Work
- Processes domain events through handlers
- Never depends on infrastructure implementations

**For Details:** See `.cursor/rules/application.mdc`

---

### Infrastructure Layer (`lykke/infrastructure/`)

**Purpose:** Implements the protocols defined in the application layer. Handles all I/O operations.

**Location:** `backend/lykke/infrastructure/`

**Key Components:**

- `repositories/` - Repository implementations using SQLAlchemy
- `gateways/` - External API implementations (Google Calendar, Web Push, LLMs, etc.)
- `database/` - SQLAlchemy table definitions and connection management
- `unit_of_work.py` - SQLAlchemy implementation of Unit of Work
- `auth/` - Authentication schemas and configuration
- `workers/` - Background worker configuration

**What It Does:**

- Implements repository protocols with database persistence
- Implements gateway protocols with external API calls
- Manages database connections and transactions
- Handles data serialization/deserialization
- Provides concrete implementations of abstractions

**For Details:** See `.cursor/rules/infrastructure.mdc`

---

### Presentation Layer (`lykke/presentation/`)

**Purpose:** HTTP API layer that translates between HTTP requests/responses and application layer.

**Location:** `backend/lykke/presentation/`

**Key Components:**

- `api/routers/` - FastAPI route handlers
- `api/schemas/` - Pydantic request/response models
- `api/schemas/mappers.py` - Functions to convert entities to schemas
- `middlewares/` - HTTP middlewares
- `workers/` - Background task workers

**What It Does:**

- Exposes REST API endpoints
- Validates HTTP requests
- Converts between API schemas and domain entities
- Delegates business logic to application layer
- Handles HTTP concerns (status codes, headers, etc.)
- Provides WebSocket endpoints for real-time updates

**For Details:** See `.cursor/rules/presentation.mdc`

---

### Core Layer (`lykke/core/`)

**Purpose:** Shared utilities, configuration, and cross-cutting concerns used by all layers.

**Location:** `backend/lykke/core/`

**Key Components:**

- `config.py` - Application settings and configuration
- `constants.py` - Application-wide constants
- `exceptions.py` - Base exception classes
- `observability.py` - Logging and monitoring utilities
- `utils/` - Stateless utility functions

**What It Does:**

- Provides configuration management
- Defines shared exception hierarchy
- Provides reusable utility functions
- Contains no business logic or layer-specific code

**For Details:** See `.cursor/rules/core.mdc`

---

## Dependency Rules Summary

| Layer          | Can Import From                           | Cannot Import From                                |
| -------------- | ----------------------------------------- | ------------------------------------------------- |
| Domain         | Core only                                 | Application, Infrastructure, Presentation         |
| Application    | Domain, Core                              | Infrastructure, Presentation                      |
| Infrastructure | Application, Domain, Core                 | Presentation                                      |
| Presentation   | Application, Domain, Infrastructure, Core | None (outermost layer)                            |
| Core           | Nothing                                   | Domain, Application, Infrastructure, Presentation |

**Golden Rule:** Inner layers never know about outer layers. Application layer uses protocols, not concrete implementations.

---

## Adding a New Feature

> **⚠️ CRITICAL: Object & Mapper Management**  
> This codebase has FOUR distinct object types (Entities, Value Objects, SQLAlchemy Tables, API Schemas) that must be kept in sync.  
> **Before adding/modifying features, read:** `.cursor/commands/object-schema-mapper-guide.md`  
> Missing mappers or using wrong object types are common errors that break the build.

When adding a new feature, work bottom-up through the layers:

### 1. Domain Layer First

- Add or update entities in `domain/entities/`
- Add or update value objects in `domain/value_objects/`
- Add domain events in `domain/events/` if needed
- Add domain services in `domain/services/` if needed

**Where to look:**

- Existing entities: `lykke/domain/entities/`
- Value object patterns: `lykke/domain/value_objects/base.py`
- Event patterns: `lykke/domain/events/base.py`

### 2. Application Layer Second

- Add repository protocols in `application/repositories/` if needed
- Add gateway protocols in `application/gateways/` if needed
- Add command handlers in `application/commands/` for write operations
- Add query handlers in `application/queries/` for read operations
- Add event handlers in `application/events/handlers/` if needed

**Where to look:**

- Command patterns: `lykke/application/commands/base.py`
- Query patterns: `lykke/application/queries/base.py`
- Repository protocols: `lykke/application/repositories/base.py`
- Unit of Work usage: `lykke/application/unit_of_work.py`

### 3. Infrastructure Layer Third

- Implement repository protocols in `infrastructure/repositories/`
- **CRITICAL:** Add `entity_to_row()` and `row_to_entity()` mappers in repository
- Implement gateway protocols in `infrastructure/gateways/` if needed
- Add database tables in `infrastructure/database/tables/` if needed
- Create Alembic migrations if schema changes

**Where to look:**

- Repository implementations: `lykke/infrastructure/repositories/base/`
- Table patterns: `lykke/infrastructure/database/tables/`
- Migration patterns: `backend/alembic/versions/`
- **Mapping guide:** `.cursor/commands/object-schema-mapper-guide.md`

### 4. Presentation Layer Last

- Add API schemas in `presentation/api/schemas/`
- **CRITICAL:** Add `map_*_to_schema()` function in `presentation/api/schemas/mappers.py`
- Add route handlers in `presentation/api/routers/`
- Add dependency injection in `presentation/api/routers/dependencies/`

**Where to look:**

- Router patterns: `lykke/presentation/api/routers/`
- Schema patterns: `lykke/presentation/api/schemas/base.py`
- Dependency patterns: `lykke/presentation/api/routers/dependencies/`
- **Mapping guide:** `.cursor/commands/object-schema-mapper-guide.md`

---

## Testing Structure

```
tests/
├── conftest.py           # Global fixtures (dates, database URL)
├── unit/                 # Unit tests - mock all dependencies
│   ├── domain/          # Test domain entities, value objects, services
│   ├── application/     # Test commands/queries with mocked repos
│   ├── gateways/        # Test gateway implementations
│   └── utils/           # Test utility functions
├── integration/         # Integration tests - real database
│   ├── repositories/    # Test repository implementations
│   └── services/        # Test service integrations
├── e2e/                 # End-to-end tests - full API flow
│   └── routers/         # Test API endpoints
└── fixtures/            # Reusable test fixtures
```

**Testing Guidelines:**

- Unit tests: Mock all dependencies using `dobles` for protocols
- Integration tests: Use real database, test repository implementations
- E2E tests: Test full HTTP API flows
- Use `freezegun` for time-dependent tests
- See layer-specific rules for detailed testing guidance

---

## Event System

The codebase uses a three-tier event system. See `.cursor/rules/events-and-audit-logs.mdc` for comprehensive guide.

### 1. DomainEvent (In-Memory)

All domain events extend `DomainEvent`:
- Emitted by entities when state changes
- Handled by `DomainEventHandler` classes
- **Execute BEFORE commit** (can modify data atomically)
- Published to Redis **AFTER commit** (all events)

### 2. Domain Event Redis Channels/Streams (Post-Commit)

After successful commit, UoW publishes serialized events:
- PubSub channel: `domain-events:{user_id}`
- Stream: `latest-domain-event` (maxlen 1)

### 3. Entity Change Stream (Incremental Sync)

UoW also appends entity changes to per-user Redis stream:
- Stream: `entity-changes`
- Includes `change_type`, `entity_type`, `entity_id`, `entity_date`, `entity_patch`
- Used by websocket incremental sync APIs

### Event Flow

```
Entity emits event
  → UoW processes entities
  → Dispatch handlers (BEFORE commit)
  → Commit transaction
  → Publish ALL domain events to Redis (AFTER commit)
  → Append entity-changes stream records (AFTER commit)
  → WebSocket clients sync by stream/event cursors
```

**Key Rules:**
- Handlers run BEFORE commit → can modify data atomically
- Redis publishing AFTER commit → external systems see only committed data
- No audit-log-table dependency in the event pipeline

---

## Common Patterns

### CQRS Pattern

- **Commands** (`application/commands/`) handle write operations using Unit of Work
- **Queries** (`application/queries/`) handle read operations using read-only repositories
- Commands and queries are separate handlers, not methods on a service class

### Unit of Work Pattern

- Commands use `UnitOfWorkFactory` to create transaction-scoped units of work
- Queries use `ReadOnlyRepositoryFactory` to create read-only repositories
- Unit of Work tracks entities via `add()` and commits/rollbacks transactions
- Domain events are dispatched before commit, then broadcast after commit

### Repository Pattern

- Protocols defined in `application/repositories/`
- Implementations in `infrastructure/repositories/`
- Read-only and read-write protocols separated
- User-scoped repositories are constructed with `user: UserEntity`
- Base user scoping is enforced by `UserScopedBaseRepository` / `BaseRepository`

### Identity Access Pattern

- Do not use a generic unscoped user repository in app flows
- Use `CurrentUserAccessProtocol` for authenticated self updates
- Use `UnauthenticatedIdentityAccessProtocol` for login/signup and cross-user identity lookups
- Keep cross-user identity access isolated to `infrastructure/unauthenticated/identity_access.py`

### Dependency Injection

- Routers use FastAPI `Depends()` for dependency injection
- Factories in `presentation/api/routers/dependencies/` create handlers
- Protocols are injected, implementations are created in dependencies

---

## Getting Help

1. **Check existing code** - Look for similar patterns in the codebase
2. **Read layer-specific rules** - Each layer has detailed rules in `.cursor/rules/`
3. **Check test examples** - Tests show how to use each layer
4. **Ask questions** - If unsure about architecture decisions, ask before implementing

---

## Code Review Checklist

Before submitting code:

- [ ] All tests pass (`make test`)
- [ ] Type checking passes (`make typecheck`)
- [ ] New code has tests (unit, integration, or E2E as appropriate)
- [ ] Layer boundaries are respected (check imports)
- [ ] Commands/queries use protocols, not implementations
- [ ] Routers are thin (delegate to handlers)
- [ ] Domain entities enforce business rules
- [ ] No business logic in presentation layer
- [ ] Domain events used for side effects
- [ ] Migrations created for schema changes
