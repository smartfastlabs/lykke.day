---
globs: backend/lykke/presentation/**/*.py
alwaysApply: false
---

# Presentation Layer Rules

The Presentation layer is the HTTP API layer that translates between HTTP requests/responses and the application layer. It uses FastAPI for routing, request validation, and response serialization.

---

## Layer Structure

```
presentation/
├── api/
│   ├── routers/           # FastAPI route handlers
│   │   ├── tasks.py       # Task routes
│   │   ├── days.py        # Day routes
│   │   ├── day_templates.py # DayTemplate routes
│   │   ├── dependencies/  # Dependency injection
│   │   │   ├── commands/  # Command handler DI (when not using factory)
│   │   │   ├── factories.py # query_handler_factory, command_handler_factory
│   │   │   ├── services/  # Service DI functions
│   │   │   └── user.py    # get_current_user, get_current_user_from_token
│   │   └── ...
│   └── schemas/           # Pydantic request/response models
│       ├── base.py        # BaseSchema, BaseEntitySchema
│       ├── task.py        # TaskSchema, TaskUpdateSchema
│       ├── day.py         # DaySchema, DayUpdateSchema
│       ├── mappers.py     # Functions to convert entities to schemas
│       └── ...
├── handler_factory.py     # QueryHandlerFactory, CommandHandlerFactory
├── middlewares/           # HTTP middlewares
└── workers/               # Background task workers (Taskiq)
    └── tasks/             # Task definitions and registration
```

---

## Import Rules

**Allowed Imports:**
- Standard library
- FastAPI and related libraries
- `lykke.application.*` - Application layer (commands, queries, protocols)
- `lykke.domain.*` - Domain layer (entities, value objects)
- `lykke.infrastructure.*` - Infrastructure layer (for dependency creation)
- `lykke.core.*` - Core layer (config, constants, exceptions, utils)
- Other presentation layer modules

**Forbidden Imports:**
- None (presentation is the outermost layer)

---

## Routers

Routers are FastAPI route handlers that define API endpoints. They should be **thin** and delegate to application layer handlers. **Prefer the Handler Factory Pattern** (inject `QueryHandlerFactory` or `CommandHandlerFactory` and call `factory.create(HandlerClass)`) for most routes; see the section below.

### Router structure (handler dependency)

```python
from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends

from lykke.application.commands import UpdateDayCommand, UpdateDayHandler
from lykke.domain.entities import UserEntity
from lykke.domain.value_objects import DayUpdateObject
from lykke.presentation.api.schemas import DaySchema, DayUpdateSchema
from lykke.presentation.api.schemas.mappers import map_day_to_schema

from .dependencies.factories import create_command_handler
from .dependencies.user import get_current_user

router = APIRouter()


@router.patch("/{day_id}", response_model=DaySchema)
async def update_day(
    day_id: UUID,
    update_data: DayUpdateSchema,
    user: Annotated[UserEntity, Depends(get_current_user)],
    handler: Annotated[
        UpdateDayHandler, Depends(create_command_handler(UpdateDayHandler))
    ],
) -> DaySchema:
    """Update a day."""
    update_object = DayUpdateObject(
        status=update_data.status,
        high_level_plan=update_data.high_level_plan,
    )
    updated = await handler.handle(
        UpdateDayCommand(day_id=day_id, update_data=update_object)
    )
    return map_day_to_schema(updated)
```

### Key Rules for Routers

1. **Keep routers thin** - Routers should only handle HTTP concerns
2. **Delegate to handlers** - All business logic goes in command/query handlers
3. **Use dependency injection** - Use FastAPI `Depends()` for handler injection
4. **Convert schemas to domain objects** - Convert request schemas to domain entities/value objects
5. **Convert entities to schemas** - Use mapper functions to convert entities to response schemas
6. **Return schemas** - Always return Pydantic schemas, not domain entities
7. **Handle HTTP errors** - Map domain exceptions to HTTP status codes
8. **Use type annotations** - Use `Annotated` with `Depends()` for dependency injection

### HTTP Status Codes

- `200 OK` - Successful GET, PUT, PATCH
- `201 Created` - Successful POST (for creation)
- `204 No Content` - Successful DELETE
- `400 Bad Request` - Invalid request data (DomainError)
- `401 Unauthorized` - Authentication required
- `403 Forbidden` - Insufficient permissions
- `404 Not Found` - Resource not found (NotFoundError)
- `422 Unprocessable Entity` - Validation error (Pydantic)

---

## Schemas

Schemas are Pydantic models that define request and response structures.

### Schema Definition

```python
from pydantic import Field
from uuid import UUID

from lykke.presentation.api.schemas.base import BaseEntitySchema, BaseSchema


class DayTemplateSchema(BaseEntitySchema):
    """Schema for DayTemplate entity."""
    
    user_id: UUID
    slug: str = Field(..., min_length=1, max_length=100)
    icon: str | None = None
    routine_ids: list[UUID] = Field(default_factory=list)


class DayTemplateUpdateSchema(BaseSchema):
    """Schema for updating a DayTemplate."""
    
    slug: str | None = Field(None, min_length=1, max_length=100)
    icon: str | None = None
    routine_ids: list[UUID] | None = None
```

### Key Rules for Schemas

1. **Extend base classes** - Use `BaseSchema`, `BaseEntitySchema`
2. **Use Field()** - Use Pydantic `Field()` for validation and documentation
3. **Optional fields** - Use `| None` for optional fields
4. **Default values** - Use `default_factory` for list defaults
5. **Separate update schemas** - Create separate schemas for updates (all fields optional)

---

## Schema Mappers

Schema mappers convert domain entities to API schemas. They are defined in `presentation/api/schemas/mappers.py`.

### Mapper Functions

```python
from lykke.domain.entities import TaskEntity
from lykke.presentation.api.schemas import TaskSchema


def map_task_to_schema(task: TaskEntity) -> TaskSchema:
    """Convert Task entity to Task schema."""
    return TaskSchema(
        id=task.id,
        user_id=task.user_id,
        scheduled_date=task.scheduled_date,
        name=task.name,
        status=task.status,
        task_definition=map_task_definition_to_schema(task.task_definition),
        category=task.category,
        frequency=task.frequency,
        completed_at=task.completed_at,
        schedule=map_task_schedule_to_schema(task.schedule) if task.schedule else None,
        routine_id=task.routine_id,
        tags=task.tags,
    )
```

### Key Rules for Mappers

1. **Pure functions** - Mappers should be pure functions with no side effects
2. **Handle nested entities** - Use recursive mapper calls for nested entities
3. **Handle None values** - Check for None before mapping nested objects
4. **Document mappers** - Add docstrings explaining what is mapped

---

## Handler Factory Pattern

Routers obtain command and query handlers via **dependency factories** that return a ready-to-use handler instance. Use `create_query_handler(HandlerClass)` and `create_command_handler(HandlerClass)` so you inject the handler directly; do not add custom DI functions per handler.

### How It Works

- **`create_query_handler(handler_class)`** – Returns a FastAPI dependency that builds `QueryHandlerFactory(user, ro_repo_factory)` and returns `factory.create(handler_class)`. Use for read-only handlers.
- **`create_command_handler(handler_class)`** – Returns a dependency that builds `CommandHandlerFactory(user, ro_repo_factory, uow_factory)` and returns `factory.create(handler_class)`. Use for write handlers.
- **WebSocket routes** – Use `create_query_handler_websocket(HandlerClass)` and `create_command_handler_websocket(HandlerClass)` (they use `get_current_user_from_token` and, for commands, `get_unit_of_work_factory_websocket`).
- **Unauthenticated auth routes** – Use `create_unauth_auth_handler(HandlerClass)` in `auth_sms.py` for handlers that take identity_access / uow_factory / sms_gateway (registry-based).

### Query Handler

```python
from typing import Annotated

from fastapi import APIRouter, Depends

from lykke.application.queries import GetDayTemplateHandler, GetDayTemplateQuery
from lykke.presentation.api.schemas.mappers import map_day_template_to_schema

from .dependencies.factories import create_query_handler

router = APIRouter()


@router.get("/{template_id}", response_model=DayTemplateSchema)
async def get_day_template(
    template_id: UUID,
    handler: Annotated[
        GetDayTemplateHandler, Depends(create_query_handler(GetDayTemplateHandler))
    ],
) -> DayTemplateSchema:
    result = await handler.handle(GetDayTemplateQuery(template_id=template_id))
    return map_day_template_to_schema(result)
```

### Command Handler

```python
@router.post("/", response_model=DayTemplateSchema, status_code=201)
async def create_day_template(
    data: DayTemplateCreateSchema,
    handler: Annotated[
        CreateDayTemplateHandler, Depends(create_command_handler(CreateDayTemplateHandler))
    ],
) -> DayTemplateSchema:
    created = await handler.handle(CreateDayTemplateCommand(**data.model_dump()))
    return map_day_template_to_schema(created)
```

### Multiple handlers in one route

When a route needs both a query and a command handler (or several handlers), inject each with a distinct parameter name:

```python
handler: Annotated[GetCalendarHandler, Depends(create_query_handler(GetCalendarHandler))],
command_handler: Annotated[SubscribeCalendarHandler, Depends(create_command_handler(SubscribeCalendarHandler))],
```

### Key Rules for the Factory Pattern

1. **Use the generic factories** – Use `Depends(create_query_handler(MyHandler))` or `Depends(create_command_handler(MyHandler))`; do not add custom `_get_*_handler` functions per handler type.
2. **Inject the handler instance** – The dependency returns a wired handler; call `await handler.handle(command_or_query)` directly.
3. **User is inside the factory** – The create_* functions pull `get_current_user` (or `get_current_user_from_token` for WebSockets) and build the handler with that user.
4. **Custom wiring** – Handlers that need gateways or other handlers are registered in `handler_factory.py` with a provider function; most handlers use the default constructor wiring.

---

## Dependency Injection

Dependency injection provides handler-instance factories (see **Handler Factory Pattern** above). Use the generic factories; do not add custom per-handler DI functions.

### Handler dependency factories

Defined in `presentation/api/routers/dependencies/factories.py`:

- **`create_query_handler(handler_class)`** – Returns a dependency that yields a wired query handler for HTTP routes. Usage: `handler: Annotated[MyHandler, Depends(create_query_handler(MyHandler))]`.
- **`create_command_handler(handler_class)`** – Returns a dependency that yields a wired command handler for HTTP routes.
- **`create_query_handler_websocket(handler_class)`** / **`create_command_handler_websocket(handler_class)`** – Same for WebSocket routes (use `get_current_user_from_token` and, for commands, `get_unit_of_work_factory_websocket`).

The same file still defines **`query_handler_factory`** and **`command_handler_factory`** for rare cases where a route needs the factory (e.g. building multiple handlers or unauthenticated flows that resolve user elsewhere). Prefer the `create_*_handler(HandlerClass)` pattern.

### Key Rules for Dependencies

1. **Use generic handler factories** – Use `Depends(create_query_handler(MyHandler))` or `Depends(create_command_handler(MyHandler))`; avoid custom `def _get_*_handler(...)` per handler.
2. **Use `Annotated` with `Depends()`** – Type annotations for dependency injection.
3. **Get user from dependencies** – User is resolved inside the create_* functions via `get_current_user` or `get_current_user_from_token`.

---

## WebSocket Endpoints

The presentation layer also handles WebSocket connections for real-time updates.

### WebSocket Pattern

```python
@router.websocket("/today/context")
async def days_context_websocket(
    websocket: WebSocket,
    pubsub_gateway: Annotated[PubSubGatewayProtocol, Depends(get_pubsub_gateway)],
    day_context_handler: Annotated[
        GetDayContextHandler,
        Depends(create_query_handler_websocket(GetDayContextHandler)),
    ],
) -> None:
    """WebSocket endpoint for real-time DayContext sync."""
    await websocket.accept()
    
    try:
        user_id = day_context_handler.user.id
        
        # Subscribe to user's domain-events channel
        async with pubsub_gateway.subscribe_to_user_channel(
            user_id=user_id, channel_type="domain-events"
        ) as subscription:
            # Handle client messages and real-time events
            ...
    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected for user {user_id}")
```

---

## Gotchas

### 1. Schema to Entity Conversion

**Issue:** Routers must convert request schemas to domain entities/value objects.

```python
# Wrong - passing schema directly
updated = await update_handler.handle(update_data)  # DayUpdateSchema

# Right - convert to domain value object
update_object = DayUpdateObject(
    status=update_data.status,
    high_level_plan=update_data.high_level_plan,
)
updated = await update_handler.handle(UpdateDayCommand(update_data=update_object))
```

### 2. Entity to Schema Conversion

**Issue:** Routers must convert domain entities to schemas before returning.

```python
# Wrong - returning entity directly
return day  # DayEntity

# Right - convert to schema
return map_day_to_schema(day)
```

### 3. List Defaults

**Issue:** Use `Field(default_factory=list)` for list defaults, not `= []`.

```python
# Wrong - mutable default
routine_ids: list[UUID] = []

# Right - default_factory
routine_ids: list[UUID] = Field(default_factory=list)
```

### 4. Dependency Injection Type Annotations

**Issue:** Use `Annotated` with `Depends()` for dependency injection.

```python
# Wrong - missing Annotated
def get_handler(handler: Depends(create_command_handler(MyHandler))): ...

# Right - use Annotated
def get_handler(
    handler: Annotated[MyHandler, Depends(create_command_handler(MyHandler))]
): ...
```

---

## Testing Guidance

### E2E Testing Routers

Test routers with full HTTP client:

```python
@pytest.mark.asyncio
async def test_update_day(authenticated_client):
    """Test updating a day."""
    client, user = await authenticated_client()
    
    update_data = {"status": "started"}
    response = client.patch(f"/days/{day_id}", json=update_data)
    
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "started"
```

### Test Location

Presentation layer tests go in:
- `tests/e2e/routers/` - Router E2E tests

### Test Patterns

1. **Test HTTP status codes** - Verify correct status codes
2. **Test response schemas** - Verify response structure matches schemas
3. **Test error handling** - Verify error responses
4. **Test validation** - Verify request validation
5. **Use fixtures** - Use authenticated client fixtures

---

## Common Patterns

### CRUD Router Pattern (handler dependency)

```python
from .dependencies.factories import create_command_handler, create_query_handler

router = APIRouter()

@router.get("/{uuid}", response_model=EntitySchema)
async def get_entity(
    uuid: UUID,
    handler: Annotated[GetEntityHandler, Depends(create_query_handler(GetEntityHandler))],
) -> EntitySchema:
    entity = await handler.handle(GetEntityQuery(entity_id=uuid))
    return map_entity_to_schema(entity)

@router.post("/", response_model=EntitySchema, status_code=201)
async def create_entity(
    data: EntityCreateSchema,
    handler: Annotated[CreateEntityHandler, Depends(create_command_handler(CreateEntityHandler))],
) -> EntitySchema:
    created = await handler.handle(CreateEntityCommand(**data.model_dump()))
    return map_entity_to_schema(created)

@router.patch("/{uuid}", response_model=EntitySchema)
async def update_entity(
    uuid: UUID,
    data: EntityUpdateSchema,
    handler: Annotated[UpdateEntityHandler, Depends(create_command_handler(UpdateEntityHandler))],
) -> EntitySchema:
    update_obj = EntityUpdateObject(**data.model_dump(exclude_unset=True))
    updated = await handler.handle(UpdateEntityCommand(entity_id=uuid, update_data=update_obj))
    return map_entity_to_schema(updated)

@router.delete("/{uuid}", status_code=204)
async def delete_entity(
    uuid: UUID,
    handler: Annotated[DeleteEntityHandler, Depends(create_command_handler(DeleteEntityHandler))],
) -> None:
    await handler.handle(DeleteEntityCommand(entity_id=uuid))
```
