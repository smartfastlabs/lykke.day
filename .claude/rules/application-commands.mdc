---
globs: backend/lykke/application/commands/**/*.py
alwaysApply: false
---

# Application Commands Rules

Commands handle write operations (mutations) that change system state. They use Unit of Work for transaction management.

---

## Command Structure

Commands follow a specific pattern with a `Command` dataclass and `CommandHandler` class:

```python
from dataclasses import dataclass
from uuid import UUID

from lykke.application.commands.base import BaseCommandHandler, Command
from lykke.application.unit_of_work import (
    ReadOnlyRepositories,
    UnitOfWorkFactory,
    UnitOfWorkProtocol,
)
from lykke.domain import value_objects
from lykke.domain.entities import DayEntity


@dataclass(frozen=True)
class ScheduleDayCommand(Command):
    """Command to schedule a day."""
    
    date: date
    template_id: UUID | None = None


class ScheduleDayHandler(BaseCommandHandler[ScheduleDayCommand, value_objects.DayContext]):
    """Schedules a day with tasks from routines."""
    
    def __init__(
        self,
        ro_repos: ReadOnlyRepositories,
        uow_factory: UnitOfWorkFactory,
        user_id: UUID,
    ) -> None:
        super().__init__(ro_repos, uow_factory, user_id)
    
    async def handle(self, command: ScheduleDayCommand) -> value_objects.DayContext:
        """Schedule a day with tasks from routines."""
        async with self.new_uow() as uow:
            # Read entities via uow ro_repo properties
            template = await uow.day_template_ro_repo.get(command.template_id)
            
            # Create new entity
            day = DayEntity.create_for_date(
                command.date,
                user_id=self.user_id,
                template=template,
            )
            
            # Create entity (marks as created and adds to UoW)
            await uow.create(day)
            
            # Create tasks
            for task in tasks:
                await uow.create(task)
            
            # commit() is called automatically when exiting context
            return value_objects.DayContext(day=day, tasks=tasks)
```

---

## Key Rules for Commands

1. **Extend BaseCommandHandler** - Use `BaseCommandHandler[CommandT, ResultT]` base class
2. **Define Command dataclass** - Use frozen dataclass extending `Command`
3. **Implement handle()** - Implement async `handle(command: CommandT) -> ResultT`
4. **Use Unit of Work** - Use `self.new_uow()` to create transaction-scoped UoW
5. **Read via `uow.*_ro_repo` properties** - Use read-only repositories from UoW
6. **Use `uow.create()` for new entities** - Marks entity as created and adds to UoW
7. **Use `uow.add()` for updates** - Track modified entities for persistence
8. **Use `uow.delete()` for deletions** - Marks entity for deletion
9. **Return domain objects** - Return entities or value objects, not infrastructure types

---

## Unit of Work Pattern

Commands use Unit of Work for transaction management:

```python
async with self.new_uow() as uow:
    # All operations share the same transaction
    day = await uow.day_ro_repo.get(day_id)
    task = await uow.task_ro_repo.get(task_id)
    
    # Modify entities
    day.update_high_level_plan(new_plan)
    
    # Track entities for persistence
    uow.add(day)
    
    # commit() is called automatically when exiting context
    # Or call await uow.commit() explicitly for early commit
```

**Important:** The `commit()` method:
1. Processes all added entities (create, update, delete based on domain events)
2. Collects domain events from all aggregates
3. Dispatches domain events to handlers (BEFORE commit)
4. Commits the database transaction
5. Publishes events to Redis (AFTER commit)

---

## Entity Lifecycle Methods

The UoW provides convenience methods for entity lifecycle:

```python
# Create new entity - marks as created, adds EntityCreatedEvent
day = DayEntity.create_for_date(date, user_id=user_id, template=template)
await uow.create(day)  # Equivalent to: day.create(); uow.add(day)

# Update entity - just add it to UoW (entity methods add appropriate events)
day.update_high_level_plan(new_plan)  # Entity method adds DayUpdatedEvent
uow.add(day)

# Delete entity - marks as deleted, adds EntityDeletedEvent
await uow.delete(day)  # Equivalent to: day.delete(); uow.add(day)

# Apply update object pattern
updated_day = day.apply_update(update_object, DayUpdatedEvent)
uow.add(updated_day)
```

---

## Gotchas

### 1. Commands Must Use Unit of Work

**Issue:** Commands must use `self.new_uow()` to create UoW. Don't create repositories directly.

```python
# Wrong
repo = TaskRepository(user_id=self.user_id)
task = await repo.get(task_id)

# Right
async with self.new_uow() as uow:
    task = await uow.task_ro_repo.get(task_id)
```

### 2. Entities Must Be Added to UoW

**Issue:** Only entities added via `uow.add()` or `uow.create()` are persisted.

```python
# Wrong
day = DayEntity.create_for_date(date, user_id=user_id, template=template)
# Entity won't be saved!

# Right
day = DayEntity.create_for_date(date, user_id=user_id, template=template)
await uow.create(day)  # Now it will be saved
```

### 3. Commits Dispatch Events

**Issue:** Domain events are dispatched during `commit()`, not when `_add_event()` is called.

```python
async with self.new_uow() as uow:
    task.complete()  # Adds TaskCompletedEvent to task._domain_events
    uow.add(task)
    # Event handlers run BEFORE database commit
    # Event is dispatched when context exits (auto-commit)
```

### 4. Use BaseCommandHandler Dependencies

**Issue:** Use inherited properties from BaseHandler for repository access.

```python
class MyHandler(BaseCommandHandler[MyCommand, MyResult]):
    async def handle(self, command: MyCommand) -> MyResult:
        # Access read-only repos directly (from BaseHandler)
        user = await self.user_ro_repo.get(self.user_id)
        
        # Or within a UoW context for transactional reads
        async with self.new_uow() as uow:
            task = await uow.task_ro_repo.get(command.task_id)
```

---

## Testing Guidance

### Unit Testing Commands

Test command handlers with mocked Unit of Work:

```python
from dobles import allow, expect

@pytest.mark.asyncio
async def test_schedule_day(mock_ro_repos, mock_uow_factory, mock_uow, test_user_id):
    """Test schedule_day command."""
    handler = ScheduleDayHandler(
        ro_repos=mock_ro_repos,
        uow_factory=mock_uow_factory,
        user_id=test_user_id,
    )
    
    # Mock UoW creation
    allow(mock_uow_factory).create(test_user_id).and_return(mock_uow)
    
    # Mock UoW context manager
    allow(mock_uow).__aenter__().and_return(mock_uow)
    allow(mock_uow).__aexit__(...).and_return(None)
    
    # Mock repository calls
    allow(mock_uow.day_template_ro_repo).get(...).and_return(template)
    
    command = ScheduleDayCommand(date=date(2025, 1, 1))
    result = await handler.handle(command)
    
    # Verify results
    assert result.day.date == date(2025, 1, 1)
```

### Test Location

Command handler tests go in:
- `tests/unit/application/commands/` - Command handler tests
- Use `dobles` for mocking protocols
- Mock all dependencies (UoW, repositories)

### Test Patterns

1. **Mock protocols** - Use `dobles` to mock protocol methods
2. **Test business logic** - Verify handlers orchestrate correctly
3. **Test error cases** - Verify error handling
4. **Test transaction boundaries** - Verify UoW usage

---

## Common Patterns

### Command Handler Pattern

```python
@dataclass(frozen=True)
class MyCommand(Command):
    entity_id: UUID
    new_value: str


class MyCommandHandler(BaseCommandHandler[MyCommand, EntityType]):
    def __init__(
        self,
        ro_repos: ReadOnlyRepositories,
        uow_factory: UnitOfWorkFactory,
        user_id: UUID,
    ) -> None:
        super().__init__(ro_repos, uow_factory, user_id)
    
    async def handle(self, command: MyCommand) -> EntityType:
        async with self.new_uow() as uow:
            # Read entity
            entity = await uow.entity_ro_repo.get(command.entity_id)
            
            # Modify entity
            entity.update_value(command.new_value)
            
            # Track entity
            uow.add(entity)
            
            return entity
```

### Injecting Other Handlers

```python
class ScheduleDayHandler(BaseCommandHandler[ScheduleDayCommand, DayContext]):
    def __init__(
        self,
        ro_repos: ReadOnlyRepositories,
        uow_factory: UnitOfWorkFactory,
        user_id: UUID,
        preview_day_handler: PreviewDayHandler,  # Injected handler
    ) -> None:
        super().__init__(ro_repos, uow_factory, user_id)
        self.preview_day_handler = preview_day_handler
    
    async def handle(self, command: ScheduleDayCommand) -> DayContext:
        # Use injected handler
        preview = await self.preview_day_handler.preview_day(command.date)
        # ...
```
