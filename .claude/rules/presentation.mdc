---
globs: backend/lykke/presentation/**/*.py
alwaysApply: false
---

# Presentation Layer Rules

The Presentation layer is the HTTP API layer that translates between HTTP requests/responses and the application layer. It uses FastAPI for routing, request validation, and response serialization.

---

## Layer Structure

```
presentation/
├── api/
│   ├── routers/           # FastAPI route handlers
│   │   ├── tasks.py       # Task routes
│   │   ├── days.py        # Day routes
│   │   ├── day_templates.py # DayTemplate routes
│   │   ├── dependencies/  # Dependency injection functions
│   │   │   ├── commands/  # Command handler DI functions
│   │   │   ├── factories.py # Factory DI functions
│   │   │   ├── services/  # Service DI functions
│   │   │   └── user.py    # User DI function
│   │   └── ...
│   └── schemas/           # Pydantic request/response models
│       ├── base.py        # BaseSchema, BaseEntitySchema
│       ├── task.py        # TaskSchema, TaskUpdateSchema
│       ├── day.py         # DaySchema, DayUpdateSchema
│       ├── mappers.py     # Functions to convert entities to schemas
│       └── ...
├── middlewares/           # HTTP middlewares
└── workers/               # Background task workers
    └── tasks.py           # Celery/background tasks
```

---

## Import Rules

**Allowed Imports:**
- Standard library
- FastAPI and related libraries
- `lykke.application.*` - Application layer (commands, queries, protocols)
- `lykke.domain.*` - Domain layer (entities, value objects)
- `lykke.infrastructure.*` - Infrastructure layer (for dependency creation)
- `lykke.core.*` - Core layer (config, constants, exceptions, utils)
- Other presentation layer modules

**Forbidden Imports:**
- None (presentation is the outermost layer)

---

## Routers

Routers are FastAPI route handlers that define API endpoints. They should be **thin** and delegate to application layer handlers.

### Router Structure

```python
from typing import Annotated
from uuid import UUID

from fastapi import APIRouter, Depends

from lykke.application.commands import (
    ScheduleDayCommand,
    ScheduleDayHandler,
    UpdateDayCommand,
    UpdateDayHandler,
)
from lykke.application.queries import GetDayContextHandler, GetDayContextQuery
from lykke.domain.entities import UserEntity
from lykke.domain.value_objects import DayUpdateObject
from lykke.presentation.api.schemas import DayContextSchema, DaySchema, DayUpdateSchema
from lykke.presentation.api.schemas.mappers import (
    map_day_context_to_schema,
    map_day_to_schema,
)

from .dependencies.services import get_update_day_handler
from .dependencies.user import get_current_user

router = APIRouter()


@router.patch("/{day_id}", response_model=DaySchema)
async def update_day(
    day_id: UUID,
    update_data: DayUpdateSchema,
    update_day_handler: Annotated[UpdateDayHandler, Depends(get_update_day_handler)],
    user: Annotated[UserEntity, Depends(get_current_user)],
) -> DaySchema:
    """Update a day."""
    update_object = DayUpdateObject(
        status=update_data.status,
        high_level_plan=update_data.high_level_plan,
    )
    updated = await update_day_handler.handle(
        UpdateDayCommand(date=day.date, update_data=update_object)
    )
    return map_day_to_schema(updated)
```

### Key Rules for Routers

1. **Keep routers thin** - Routers should only handle HTTP concerns
2. **Delegate to handlers** - All business logic goes in command/query handlers
3. **Use dependency injection** - Use FastAPI `Depends()` for handler injection
4. **Convert schemas to domain objects** - Convert request schemas to domain entities/value objects
5. **Convert entities to schemas** - Use mapper functions to convert entities to response schemas
6. **Return schemas** - Always return Pydantic schemas, not domain entities
7. **Handle HTTP errors** - Map domain exceptions to HTTP status codes
8. **Use type annotations** - Use `Annotated` with `Depends()` for dependency injection

### HTTP Status Codes

- `200 OK` - Successful GET, PUT, PATCH
- `201 Created` - Successful POST (for creation)
- `204 No Content` - Successful DELETE
- `400 Bad Request` - Invalid request data (DomainError)
- `401 Unauthorized` - Authentication required
- `403 Forbidden` - Insufficient permissions
- `404 Not Found` - Resource not found (NotFoundError)
- `422 Unprocessable Entity` - Validation error (Pydantic)

---

## Schemas

Schemas are Pydantic models that define request and response structures.

### Schema Definition

```python
from pydantic import Field
from uuid import UUID

from lykke.presentation.api.schemas.base import BaseEntitySchema, BaseSchema


class DayTemplateSchema(BaseEntitySchema):
    """Schema for DayTemplate entity."""
    
    user_id: UUID
    slug: str = Field(..., min_length=1, max_length=100)
    icon: str | None = None
    routine_ids: list[UUID] = Field(default_factory=list)


class DayTemplateUpdateSchema(BaseSchema):
    """Schema for updating a DayTemplate."""
    
    slug: str | None = Field(None, min_length=1, max_length=100)
    icon: str | None = None
    routine_ids: list[UUID] | None = None
```

### Key Rules for Schemas

1. **Extend base classes** - Use `BaseSchema`, `BaseEntitySchema`
2. **Use Field()** - Use Pydantic `Field()` for validation and documentation
3. **Optional fields** - Use `| None` for optional fields
4. **Default values** - Use `default_factory` for list defaults
5. **Separate update schemas** - Create separate schemas for updates (all fields optional)

---

## Schema Mappers

Schema mappers convert domain entities to API schemas. They are defined in `presentation/api/schemas/mappers.py`.

### Mapper Functions

```python
from lykke.domain.entities import TaskEntity
from lykke.presentation.api.schemas import TaskSchema


def map_task_to_schema(task: TaskEntity) -> TaskSchema:
    """Convert Task entity to Task schema."""
    return TaskSchema(
        id=task.id,
        user_id=task.user_id,
        scheduled_date=task.scheduled_date,
        name=task.name,
        status=task.status,
        task_definition=map_task_definition_to_schema(task.task_definition),
        category=task.category,
        frequency=task.frequency,
        completed_at=task.completed_at,
        schedule=map_task_schedule_to_schema(task.schedule) if task.schedule else None,
        routine_id=task.routine_id,
        tags=task.tags,
    )
```

### Key Rules for Mappers

1. **Pure functions** - Mappers should be pure functions with no side effects
2. **Handle nested entities** - Use recursive mapper calls for nested entities
3. **Handle None values** - Check for None before mapping nested objects
4. **Document mappers** - Add docstrings explaining what is mapped

---

## Dependency Injection

Dependency injection functions create handler instances with their dependencies.

### Dependency Functions

```python
from typing import Annotated

from fastapi import Depends

from lykke.application.commands.day import UpdateDayHandler
from lykke.application.unit_of_work import ReadOnlyRepositoryFactory, UnitOfWorkFactory
from lykke.domain.entities import UserEntity

from .factories import get_read_only_repository_factory, get_unit_of_work_factory
from .user import get_current_user


def get_update_day_handler(
    ro_repo_factory: Annotated[
        ReadOnlyRepositoryFactory, Depends(get_read_only_repository_factory)
    ],
    uow_factory: Annotated[UnitOfWorkFactory, Depends(get_unit_of_work_factory)],
    user: Annotated[UserEntity, Depends(get_current_user)],
) -> UpdateDayHandler:
    """Get an UpdateDayHandler instance."""
    ro_repos = ro_repo_factory.create(user.id)
    return UpdateDayHandler(ro_repos, uow_factory, user.id)
```

### Key Rules for Dependencies

1. **Use `Annotated` with `Depends()`** - Use type annotations for dependency injection
2. **Create handler instances** - Return handler instances, not classes
3. **Inject dependencies** - Use `Depends()` for handler dependencies
4. **Get user from dependencies** - Get user from `get_current_user` dependency

---

## WebSocket Endpoints

The presentation layer also handles WebSocket connections for real-time updates.

### WebSocket Pattern

```python
@router.websocket("/today/context")
async def days_context_websocket(
    websocket: WebSocket,
    pubsub_gateway: Annotated[PubSubGatewayProtocol, Depends(get_pubsub_gateway)],
    day_context_handler: Annotated[GetDayContextHandler, Depends(day_context_handler_websocket)],
) -> None:
    """WebSocket endpoint for real-time DayContext sync."""
    await websocket.accept()
    
    try:
        user_id = day_context_handler.user_id
        
        # Subscribe to user's domain-events channel
        async with pubsub_gateway.subscribe_to_user_channel(
            user_id=user_id, channel_type="domain-events"
        ) as subscription:
            # Handle client messages and real-time events
            ...
    except WebSocketDisconnect:
        logger.info(f"WebSocket disconnected for user {user_id}")
```

---

## Gotchas

### 1. Schema to Entity Conversion

**Issue:** Routers must convert request schemas to domain entities/value objects.

```python
# Wrong - passing schema directly
updated = await update_handler.handle(update_data)  # DayUpdateSchema

# Right - convert to domain value object
update_object = DayUpdateObject(
    status=update_data.status,
    high_level_plan=update_data.high_level_plan,
)
updated = await update_handler.handle(UpdateDayCommand(update_data=update_object))
```

### 2. Entity to Schema Conversion

**Issue:** Routers must convert domain entities to schemas before returning.

```python
# Wrong - returning entity directly
return day  # DayEntity

# Right - convert to schema
return map_day_to_schema(day)
```

### 3. List Defaults

**Issue:** Use `Field(default_factory=list)` for list defaults, not `= []`.

```python
# Wrong - mutable default
routine_ids: list[UUID] = []

# Right - default_factory
routine_ids: list[UUID] = Field(default_factory=list)
```

### 4. Dependency Injection Type Annotations

**Issue:** Use `Annotated` with `Depends()` for dependency injection.

```python
# Wrong - missing Annotated
def get_handler(handler: Depends(get_handler_factory)): ...

# Right - use Annotated
def get_handler(
    handler: Annotated[Handler, Depends(get_handler_factory)]
): ...
```

---

## Testing Guidance

### E2E Testing Routers

Test routers with full HTTP client:

```python
@pytest.mark.asyncio
async def test_update_day(authenticated_client):
    """Test updating a day."""
    client, user = await authenticated_client()
    
    update_data = {"status": "started"}
    response = client.patch(f"/days/{day_id}", json=update_data)
    
    assert response.status_code == 200
    data = response.json()
    assert data["status"] == "started"
```

### Test Location

Presentation layer tests go in:
- `tests/e2e/routers/` - Router E2E tests

### Test Patterns

1. **Test HTTP status codes** - Verify correct status codes
2. **Test response schemas** - Verify response structure matches schemas
3. **Test error handling** - Verify error responses
4. **Test validation** - Verify request validation
5. **Use fixtures** - Use authenticated client fixtures

---

## Common Patterns

### CRUD Router Pattern

```python
router = APIRouter()

@router.get("/{uuid}", response_model=EntitySchema)
async def get_entity(
    uuid: UUID,
    handler: Annotated[GetHandler, Depends(get_get_handler)],
) -> EntitySchema:
    entity = await handler.handle(GetEntityQuery(entity_id=uuid))
    return map_entity_to_schema(entity)

@router.post("/", response_model=EntitySchema, status_code=201)
async def create_entity(
    data: EntityCreateSchema,
    user: Annotated[UserEntity, Depends(get_current_user)],
    handler: Annotated[CreateHandler, Depends(get_create_handler)],
) -> EntitySchema:
    created = await handler.handle(CreateEntityCommand(**data.model_dump()))
    return map_entity_to_schema(created)

@router.patch("/{uuid}", response_model=EntitySchema)
async def update_entity(
    uuid: UUID,
    data: EntityUpdateSchema,
    handler: Annotated[UpdateHandler, Depends(get_update_handler)],
) -> EntitySchema:
    update_obj = EntityUpdateObject(**data.model_dump(exclude_unset=True))
    updated = await handler.handle(UpdateEntityCommand(entity_id=uuid, update_data=update_obj))
    return map_entity_to_schema(updated)

@router.delete("/{uuid}", status_code=204)
async def delete_entity(
    uuid: UUID,
    handler: Annotated[DeleteHandler, Depends(get_delete_handler)],
) -> None:
    await handler.handle(DeleteEntityCommand(entity_id=uuid))
```
